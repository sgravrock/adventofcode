#!/usr/bin/env ruby

Coord = Data.define(:x, :y) do
	def each_neighbor
		yield Coord.new(x, y - 1)
		yield Coord.new(x, y + 1)
		yield Coord.new(x + 1, y)
		yield Coord.new(x - 1, y)
	end
end

def find_start(grid)
	(0..grid.length - 1).each do |y|
		(0..grid[y].length - 1).each do |x|
			if grid[y][x] == 'S' then
				return Coord.new(x, y)
			end
		end
	end

	raise "Start not found"
end

def print_grid(grid)
	(0..grid.length - 1).each do |y|
		(0..grid[y].length - 1).each do |x|
			coord = Coord.new(x, y)
			print(yield grid[y][x], coord)
		end
		puts
	end
end

def solve(grid, max_path_len)
	reachable = Set.new
	find_reachable(grid, find_start(grid), max_path_len, reachable)

	print_grid(grid) { |cell, coord|
		if reachable.include?(coord) then
			"O"
		else
			cell
		end
	}

	reachable.size
end

# Recursively find all paths of length path_len,
# adding their ends to result
def find_reachable(grid, start, path_len, result)
	cell = grid[start.y][start.x]
	is_garden = cell == '.' || cell == 'S'

	if path_len == 0 then
		if is_garden then
			result.add(start)
		end
	elsif is_garden then
		height = grid.length
		width = grid[0].length

		start.each_neighbor do |n|
			if n.y >= 0 && n.y < height && n.x >= 0 && n.x < width then
				find_reachable(grid, n, path_len - 1, result)
			end
		end
	end
end

unless ARGV.length == 2 then
	puts "Usage: #{$0} input-file path-len"
	exit(1)
end

grid = File.read(ARGV[0]).split("\n").map(&:chars)
puts solve(grid, ARGV[1].to_i)
