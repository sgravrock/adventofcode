#!/usr/bin/env ruby

Coord = Data.define(:x, :y) do
	def north = Coord.new(x, y - 1)
	def south = Coord.new(x, y + 1)
	def east = Coord.new(x + 1, y)
	def west = Coord.new(x - 1, y)
end

Beam = Data.define(:coord, :direction) do
	def advance(new_direction)
		Beam.new(coord.public_send(new_direction), new_direction)
	end
end

class Grid
	class << self
		def parse(input)
			rows = input.split("\n").map { |line| line.chars }
			Grid.new(rows)
		end
	end

	def initialize(rows)
		@rows = rows
	end

	def height
		@rows.length
	end

	def width
		@rows[0].length
	end

	def at(coord)
		@rows[coord.y][coord.x]
	end

	def in_bounds?(c)
		c.y >= 0 && c.y < @rows.length && c.x >= 0 && c.x < @rows[0].length
	end
end


class EnergizeableGrid
	def initialize(grid)
		@grid = grid
		# Maps from coordinate to directions energized in
		@energized = Hash.new { |h, k|
			h[k] = Set.new
		}
	end

	def at(coord) = @grid.at(coord)
	def in_bounds?(c) = @grid.in_bounds?(c)

	def energize(beam)
		@energized[beam.coord].add(beam.direction)
	end

	def energized?(coord)
		@energized.include?(coord)
	end

	def energized_by?(beam)
		@energized[beam.coord].include?(beam.direction)
	end

	def num_energized
		@energized.count
	end
end


class InitialBeams
	include Enumerable

	def initialize(grid)
		@grid = grid
	end

	def each
		maxX = @grid.width - 1
		maxY = @grid.height - 1

		(0..maxX).each do |x|
			yield Beam.new(Coord.new(x, 0), :south)
			yield Beam.new(Coord.new(x, maxY), :north)
		end

		(0..maxY).each do |y|
			yield Beam.new(Coord.new(y, 0), :east)
			yield Beam.new(Coord.new(y, maxX), :west)
		end
	end
end


def advance(beam, grid)
	t = grid.at(beam.coord)

	case [t, beam.direction]
	in ['/', :north]
		nds = [:east]
	in ['/', :south]
		# Not in sample
		nds = [:west]
	in ['/', :east]
		nds = [:north]
	in ['/', :west]
		# Not in sample
		nds = [:south]
	in ['\\', :north]
		nds = [:west]
	in ['\\', :south]
		# Not in sample
		nds = [:east]
	in ['\\', :east]
		nds = [:south]
	in ['\\', :west]
		nds = [:north]
	in ['-', :north | :south]
		nds = [:east, :west]
	in ['|', :east | :west]
		nds = [:north, :south]
	else # ., - with east/west, or | with north/south
		nds = [beam.direction]
	end

	nds.map { |nd| beam.advance(nd) }
end

def num_energized_from(grid, starting_beam)
	beams = [starting_beam]

	while not beams.empty? do
		beams.each do |b|
			grid.energize(b)
		end

		beams = beams
			.flat_map { |b| advance(b, grid) }
			.filter { |b|
				grid.in_bounds?(b.coord) && 
					# Avoid infinite loops
					!grid.energized_by?(b)
			}
	end

	grid.num_energized
end

def solve(grid)
	InitialBeams.new(grid)
		.map { |start| num_energized_from(EnergizeableGrid.new(grid), start) }
		.max
end

puts solve(Grid.parse(ARGF.read))
