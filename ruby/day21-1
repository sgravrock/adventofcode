#!/usr/bin/env ruby

require './microtest'

Rule = Struct.new(:input_lines, :output_lines) do
	def matches?(grid)
		grid = grid.split("\n")
		grid == input_lines ||
			hflip(grid) == input_lines ||
			vflip(grid) == input_lines ||
			ror(grid) == input_lines ||
			ror(ror(grid)) == input_lines ||
			ror(ror(ror(grid))) == input_lines
	end
end

def hflip(grid_lines)
	grid_lines.map {|line| line.reverse}
end

def vflip(grid_lines)
	grid_lines.reverse
end

def ror(grid_lines)
	if grid_lines.length == 2
		return [
			grid_lines[1][0] + grid_lines[0][0],
			grid_lines[1][1] + grid_lines[0][1]
		]
	elsif grid_lines.length == 3
		return [
			grid_lines[2][0] + grid_lines[1][0] + grid_lines[0][0],
			grid_lines[2][1] + grid_lines[1][1] + grid_lines[0][1],
			grid_lines[2][2] + grid_lines[1][2] + grid_lines[0][2],
		]
	else
		raise "Don't know how to rotate this size (#{grid_lines.length})"
	end
end

def parse_rules(input)
	input.split("\n").map do |line|
		in_out = line.split(' => ')
		Rule.new(in_out[0].split('/'), in_out[1].split('/'))
	end
end

def iterate(grid)
	grid = default_grid if grid.nil?
	grid
end

def default_grid
	".#.\n..#\n###"
end

def split(grid)
	blocks_per_side = grid.length / 3
	(0..blocks_per_side - 1).map do |by|
		(0..blocks_per_side - 1).map do |bx|
			extract_block grid, by, bx
		end
	end
end

def join(grids)
	input_grid_size = grids[0][0].length
	size = grids.length * input_grid_size

	(0..size - 1).map do |y|
		(0..size - 1).map do |x|
			g = grids[y / input_grid_size][x / input_grid_size]
			g[y % input_grid_size][x % input_grid_size]
		end
	end
end

def extract_block(grid, by, bx)
	(0..2).map do |y|
		(0..2).map do |x|
			grid[by * 3 + y][bx * 3 + x]
		end
	end
end

class Tests < Microtest::Test
	def test_parse_rules
		input = <<~END
			../.. => .#./.../###
			#./.. => .#./##./#..
		END
		expected = [
			Rule.new(['..', '..'], ['.#.', '...', '###']),
			Rule.new(['#.', '..'], ['.#.', '##.', '#..'])
		]
		assert_equal expected, parse_rules(input)
	end

	def test_rule_matches_exact
		rule = Rule.new(['.#.', '..#', '###'], [])
		grid = <<~END
			.#.
			..#
			###
		END
		assert_equal true, rule.matches?(grid)
	end

	def test_rule_matches_false
		rule = Rule.new(['.#.', '..#', '###'], [])
		grid = <<~END
			.##
			..#
			###
		END
		assert_equal false, rule.matches?(grid)
	end

	def test_rule_matches_hflip
		rule = Rule.new(['.#.', '..#', '###'], [])
		grid = <<~END
			.#.
			#..
			###
		END
		assert_equal true, rule.matches?(grid)
	end

	def test_rule_matches_vflip
		rule = Rule.new(['.#.', '..#', '###'], [])
		grid = <<~END
			###
			..#
			.#.
		END
		assert_equal true, rule.matches?(grid)
	end

	def test_rule_matches_ror_3times
		rule = Rule.new(['.#.', '..#', '###'], [])
		grid = <<~END
			#..
			#.#
			##.
		END
		assert_equal true, rule.matches?(grid)
	end

	def test_rule_matches_2x2_1
		rule = Rule.new(['..', '.#'], [])
		grid = <<~END
			#.
			..
		END
		assert_equal true, rule.matches?(grid)
	end

	def test_rule_matches_2x2_2
		rule = Rule.new(['..', '.#'], [])
		grid = <<~END
			.#
			..
		END
		assert_equal true, rule.matches?(grid)
	end

	def test_rule_matches_2x2_3
		rule = Rule.new(['..', '.#'], [])
		grid = <<~END
			..
			.#
		END
		assert_equal true, rule.matches?(grid)
	end

	def test_rule_matches_2x2_4
		rule = Rule.new(['..', '.#'], [])
		grid = <<~END
			..
			#.
		END
		assert_equal true, rule.matches?(grid)
	end

	def test_ror_2
		input = [
			'ab',
			'cd'
		]
		expected = [
			'ca',
			'db'
		]
		assert_equal expected, ror(input)
	end

	def test_ror_3
		input = [
			'abc',
			'def',
			'ghi'
		]
		expected = [
			'gda',
			'heb',
			'ifc'
		]
		assert_equal expected, ror(input)
	end

	def xtest_iterate_3by3
		input = <<~END
			../.# => ##./#../...
			.#./..#/### => #..#/..../..../#..#
		END
		rules = parse_rules(input)
		expected = <<~END
			#..#
			....
			....
			#..#
		END
		actual = iterate(nil)
		assert_equal expected, actual
	end

	def xtest_iterate_4by4
		input = <<~END
			../.# => ##./#../...
			.#./..#/### => #..#/..../..../#..#
		END
		rules = parse_rules(input)
		input = <<~END
			#..#
			....
			....
			#..#
		END
		expected = <<~END
			##.##.
			#..#..
			......
			##.##.
			#..#..
			......
		END
		actual = iterate(input)
		assert_equal expected, actual
	end

	def test_extract_block_3
		input = [
			'##.#.#',
			'#..#..',
			'......',
			'##.##.',
			'#..#..',
			'.#...#'
		].map {|s| s.chars}
		expected = [
			'##.',
			'#..',
			'..#'
		].map {|s| s.chars }
		assert_equal expected, extract_block(input, 1, 1)
	end

	def test_split_3
		input = [
			'##.#.#',
			'#..#..',
			'......',
			'##.##.',
			'#..#..',
			'.#...#'
		].map {|s| s.chars}
		expected = [
			[
				[
					'##.',
					'#..',
					'...'
				].map {|s| s.chars },
				[
					'#.#',
					'#..',
					'...'
				].map {|s| s.chars }
			],
			[
				[
					'##.',
					'#..',
					'.#.'
				].map {|s| s.chars },
				[
					'##.',
					'#..',
					'..#'
				].map {|s| s.chars }
			]
		]
		assert_equal expected, split(input)
	end

	def test_join_3
		expected = [
			'##.#.#',
			'#..#..',
			'......',
			'##.##.',
			'#..#..',
			'.#...#'
		].map {|s| s.chars}
		input = [
			[
				[
					'##.',
					'#..',
					'...'
				].map {|s| s.chars },
				[
					'#.#',
					'#..',
					'...'
				].map {|s| s.chars }
			],
			[
				[
					'##.',
					'#..',
					'.#.'
				].map {|s| s.chars },
				[
					'##.',
					'#..',
					'..#'
				].map {|s| s.chars }
			]
		]
		assert_equal expected, join(input)
	end
end

Microtest.run(Tests.new)

__END__
